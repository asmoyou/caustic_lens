import * as THREE from 'three';
import { LensGeometry } from '../types';

// 公共下载文件方法
const downloadFile = (content: string, filename: string, mimeType: string): void => {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
};

// STL导出器
export class STLExporter {
  static export(geometry: LensGeometry, filename: string = 'lens.stl'): void {
    const stlString = this.generateSTL(geometry);
    downloadFile(stlString, filename, 'application/octet-stream');
  }

  private static generateSTL(geometry: LensGeometry): string {
    let stl = 'solid lens\n';
    
    // 遍历所有面片
    for (const face of geometry.faces) {
      const v1 = geometry.vertices[face[0]];
      const v2 = geometry.vertices[face[1]];
      const v3 = geometry.vertices[face[2]];
      
      // 计算法向量
      const normal = this.calculateNormal(v1, v2, v3);
      
      stl += `  facet normal ${normal.x} ${normal.y} ${normal.z}\n`;
      stl += '    outer loop\n';
      stl += `      vertex ${v1.x} ${v1.y} ${v1.z}\n`;
      stl += `      vertex ${v2.x} ${v2.y} ${v2.z}\n`;
      stl += `      vertex ${v3.x} ${v3.y} ${v3.z}\n`;
      stl += '    endloop\n';
      stl += '  endfacet\n';
    }
    
    stl += 'endsolid lens\n';
    return stl;
  }

  private static calculateNormal(v1: any, v2: any, v3: any): THREE.Vector3 {
    const vec1 = new THREE.Vector3(v2.x - v1.x, v2.y - v1.y, v2.z - v1.z);
    const vec2 = new THREE.Vector3(v3.x - v1.x, v3.y - v1.y, v3.z - v1.z);
    return vec1.cross(vec2).normalize();
  }

}

// OBJ导出器
export class OBJExporter {
  static export(geometry: LensGeometry, filename: string = 'lens.obj'): void {
    const objString = this.generateOBJ(geometry);
    downloadFile(objString, filename, 'text/plain');
  }

  private static generateOBJ(geometry: LensGeometry): string {
    let obj = '# Caustic Lens OBJ File\n';
    obj += '# Generated by Caustic Lens Designer\n\n';
    
    // 写入顶点
    obj += '# Vertices\n';
    for (const vertex of geometry.vertices) {
      obj += `v ${vertex.x} ${vertex.y} ${vertex.z}\n`;
    }
    
    // 写入法向量
    obj += '\n# Normals\n';
    for (const normal of geometry.normals) {
      obj += `vn ${normal.x} ${normal.y} ${normal.z}\n`;
    }
    
    // 写入UV坐标
    obj += '\n# Texture Coordinates\n';
    for (const uv of geometry.uvs) {
      obj += `vt ${uv.x} ${uv.y}\n`;
    }
    
    // 写入面片 (OBJ索引从1开始)
    obj += '\n# Faces\n';
    for (const face of geometry.faces) {
      const v1 = face[0] + 1;
      const v2 = face[1] + 1;
      const v3 = face[2] + 1;
      obj += `f ${v1}/${v1}/${v1} ${v2}/${v2}/${v2} ${v3}/${v3}/${v3}\n`;
    }
    
    return obj;
  }

}

// G-Code导出器（用于3D打印）
export class GCodeExporter {
  static export(
    geometry: LensGeometry, 
    settings: GCodeSettings = {},
    filename: string = 'lens.gcode'
  ): void {
    const gcode = this.generateGCode(geometry, settings);
    downloadFile(gcode, filename, 'text/plain');
  }

  private static generateGCode(geometry: LensGeometry, settings: GCodeSettings): string {
    const config = {
      layerHeight: 0.2,
      printSpeed: 50,
      travelSpeed: 120,
      extrusionMultiplier: 1.0,
      bedTemp: 60,
      hotendTemp: 200,
      ...settings
    };

    let gcode = '; Caustic Lens G-Code\n';
    gcode += '; Generated by Caustic Lens Designer\n';
    gcode += `; Layer Height: ${config.layerHeight}mm\n`;
    gcode += `; Print Speed: ${config.printSpeed}mm/s\n\n`;
    
    // 初始化代码
    gcode += '; Initialization\n';
    gcode += 'G21 ; Set units to millimeters\n';
    gcode += 'G90 ; Use absolute coordinates\n';
    gcode += 'M82 ; Use absolute distances for extrusion\n';
    gcode += `M190 S${config.bedTemp} ; Set bed temperature and wait\n`;
    gcode += `M109 S${config.hotendTemp} ; Set hotend temperature and wait\n`;
    gcode += 'G28 ; Home all axes\n';
    gcode += 'G1 Z15.0 F6000 ; Move the platform down 15mm\n\n';
    
    // 计算边界框
    const bounds = this.calculateBounds(geometry);
    const centerX = (bounds.min.x + bounds.max.x) / 2;
    const centerY = (bounds.min.y + bounds.max.y) / 2;
    
    // 生成层片
    const layers = this.sliceGeometry(geometry, config.layerHeight);
    
    gcode += '; Start printing\n';
    for (let i = 0; i < layers.length; i++) {
      const z = bounds.min.z + i * config.layerHeight;
      gcode += `; Layer ${i + 1}\n`;
      gcode += `G1 Z${z.toFixed(3)} F${config.printSpeed * 60}\n`;
      
      // 简化的层片打印逻辑
      const layer = layers[i];
      for (const path of layer) {
        gcode += `G1 X${(path.x + centerX).toFixed(3)} Y${(path.y + centerY).toFixed(3)} F${config.travelSpeed * 60}\n`;
        gcode += `G1 E${(i * 0.1).toFixed(3)} F${config.printSpeed * 60}\n`;
      }
    }
    
    // 结束代码
    gcode += '\n; End of print\n';
    gcode += 'M104 S0 ; Turn off hotend\n';
    gcode += 'M140 S0 ; Turn off bed\n';
    gcode += 'G91 ; Relative positioning\n';
    gcode += 'G1 E-1 F300 ; Retract the filament\n';
    gcode += 'G1 Z+0.5 X-20 Y-20 F3000 ; Move up and away\n';
    gcode += 'G28 X0 ; Home X axis\n';
    gcode += 'M84 ; Disable steppers\n';
    
    return gcode;
  }

  private static calculateBounds(geometry: LensGeometry): { min: THREE.Vector3, max: THREE.Vector3 } {
    const min = new THREE.Vector3(Infinity, Infinity, Infinity);
    const max = new THREE.Vector3(-Infinity, -Infinity, -Infinity);
    
    for (const vertex of geometry.vertices) {
      min.x = Math.min(min.x, vertex.x);
      min.y = Math.min(min.y, vertex.y);
      min.z = Math.min(min.z, vertex.z);
      max.x = Math.max(max.x, vertex.x);
      max.y = Math.max(max.y, vertex.y);
      max.z = Math.max(max.z, vertex.z);
    }
    
    return { min, max };
  }

  private static sliceGeometry(geometry: LensGeometry, layerHeight: number): Array<Array<{x: number, y: number}>> {
    const bounds = this.calculateBounds(geometry);
    const numLayers = Math.ceil((bounds.max.z - bounds.min.z) / layerHeight);
    const layers: Array<Array<{x: number, y: number}>> = [];
    
    // 简化的切片算法
    for (let i = 0; i < numLayers; i++) {
      const z = bounds.min.z + i * layerHeight;
      const layer: Array<{x: number, y: number}> = [];
      
      // 在当前Z高度找到所有相交的边
      for (const face of geometry.faces) {
        const v1 = geometry.vertices[face[0]];
        const v2 = geometry.vertices[face[1]];
        const v3 = geometry.vertices[face[2]];
        
        // 简化：只添加面片的中心点
        if ((v1.z <= z && v2.z >= z) || (v1.z >= z && v2.z <= z) ||
            (v2.z <= z && v3.z >= z) || (v2.z >= z && v3.z <= z) ||
            (v3.z <= z && v1.z >= z) || (v3.z >= z && v1.z <= z)) {
          const centerX = (v1.x + v2.x + v3.x) / 3;
          const centerY = (v1.y + v2.y + v3.y) / 3;
          layer.push({ x: centerX, y: centerY });
        }
      }
      
      layers.push(layer);
    }
    
    return layers;
  }

}

// PLY导出器
export class PLYExporter {
  static export(geometry: LensGeometry, filename: string = 'lens.ply'): void {
    const plyString = this.generatePLY(geometry);
    downloadFile(plyString, filename, 'application/octet-stream');
  }

  private static generatePLY(geometry: LensGeometry): string {
    let ply = 'ply\n';
    ply += 'format ascii 1.0\n';
    ply += 'comment Generated by Caustic Lens Designer\n';
    ply += `element vertex ${geometry.vertices.length}\n`;
    ply += 'property float x\n';
    ply += 'property float y\n';
    ply += 'property float z\n';
    ply += 'property float nx\n';
    ply += 'property float ny\n';
    ply += 'property float nz\n';
    ply += `element face ${geometry.faces.length}\n`;
    ply += 'property list uchar int vertex_indices\n';
    ply += 'end_header\n';
    
    // 写入顶点数据
    for (let i = 0; i < geometry.vertices.length; i++) {
      const vertex = geometry.vertices[i];
      const normal = geometry.normals[i] || { x: 0, y: 0, z: 1 };
      ply += `${vertex.x} ${vertex.y} ${vertex.z} ${normal.x} ${normal.y} ${normal.z}\n`;
    }
    
    // 写入面片数据
    for (const face of geometry.faces) {
      ply += `3 ${face[0]} ${face[1]} ${face[2]}\n`;
    }
    
    return ply;
  }

}

// 导出设置接口
export interface GCodeSettings {
  layerHeight?: number;
  printSpeed?: number;
  travelSpeed?: number;
  extrusionMultiplier?: number;
  bedTemp?: number;
  hotendTemp?: number;
}

export interface ExportOptions {
  format: 'stl' | 'obj' | 'gcode' | 'ply';
  filename?: string;
  gCodeSettings?: GCodeSettings;
}

// 统一导出函数
export const exportGeometry = (geometry: LensGeometry, options: ExportOptions): void => {
  const { format, filename, gCodeSettings } = options;
  
  switch (format) {
    case 'stl':
      STLExporter.export(geometry, filename);
      break;
    case 'obj':
      OBJExporter.export(geometry, filename);
      break;
    case 'gcode':
      GCodeExporter.export(geometry, gCodeSettings, filename);
      break;
    case 'ply':
      PLYExporter.export(geometry, filename);
      break;
    default:
      throw new Error(`Unsupported export format: ${format}`);
  }
};

// 导出格式信息
export const EXPORT_FORMATS = {
  stl: {
    name: 'STL',
    description: '3D打印标准格式',
    extension: '.stl',
    mimeType: 'application/octet-stream'
  },
  obj: {
    name: 'OBJ',
    description: 'Wavefront OBJ格式',
    extension: '.obj',
    mimeType: 'text/plain'
  },
  gcode: {
    name: 'G-Code',
    description: '3D打印机指令文件',
    extension: '.gcode',
    mimeType: 'text/plain'
  },
  ply: {
    name: 'PLY',
    description: 'Stanford PLY格式',
    extension: '.ply',
    mimeType: 'application/octet-stream'
  }
} as const;