import React, { useState } from 'react';
import { Card, Button, Select, Space, Typography, message, Progress } from 'antd';
import { DownloadOutlined, FileOutlined } from '@ant-design/icons';
import { saveAs } from 'file-saver';
import { useProjectStore } from '../../stores/projectStore';
import { LensGeometry } from '../../types';
import { PLYExporter, STEPExporter } from '../../utils/exportUtils';

const { Text } = Typography;
const { Option } = Select;

type ExportFormat = 'stl' | 'obj' | 'gcode' | 'ply' | 'step' | 'json';

interface ExportOptions {
  format: ExportFormat;
  scale: number;
  units: 'mm' | 'cm' | 'inch';
}

export const ExportPanel: React.FC = () => {
  const { geometry, currentImage } = useProjectStore();
  const [exportOptions, setExportOptions] = useState<ExportOptions>({
    format: 'stl',
    scale: 1,
    units: 'mm',
  });
  const [exporting, setExporting] = useState(false);
  const [progress, setProgress] = useState(0);

  // 生成二进制STL格式 - 比ASCII格式小很多
  const generateBinarySTL = (geometry: LensGeometry, scale: number): ArrayBuffer => {
    console.log('二进制STL导出 - 几何数据:', {
      vertices: geometry.vertices.length,
      faces: geometry.faces.length,
      scale: scale
    });
    
    const faceCount = geometry.faces.length;
    // 二进制STL格式：80字节头部 + 4字节面片数 + 每个面片50字节
    const bufferSize = 80 + 4 + (faceCount * 50);
    const buffer = new ArrayBuffer(bufferSize);
    const view = new DataView(buffer);
    
    // 写入80字节头部（通常为空或包含描述信息）
    const header = 'Binary STL generated by Caustic Lens Designer';
    for (let i = 0; i < Math.min(header.length, 80); i++) {
      view.setUint8(i, header.charCodeAt(i));
    }
    
    // 写入面片数量（小端序）
    view.setUint32(80, faceCount, true);
    
    let offset = 84;
    
    for (const face of geometry.faces) {
      const v1 = geometry.vertices[face[0]];
      const v2 = geometry.vertices[face[1]];
      const v3 = geometry.vertices[face[2]];
      
      // 计算法向量
      const edge1 = {
        x: (v2.x - v1.x) * scale,
        y: (v2.y - v1.y) * scale,
        z: (v2.z - v1.z) * scale,
      };
      const edge2 = {
        x: (v3.x - v1.x) * scale,
        y: (v3.y - v1.y) * scale,
        z: (v3.z - v1.z) * scale,
      };
      
      const normal = {
        x: edge1.y * edge2.z - edge1.z * edge2.y,
        y: edge1.z * edge2.x - edge1.x * edge2.z,
        z: edge1.x * edge2.y - edge1.y * edge2.x,
      };
      
      const length = Math.sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);
      if (length > 0) {
        normal.x /= length;
        normal.y /= length;
        normal.z /= length;
      }
      
      // 写入法向量（12字节，3个float32）
      view.setFloat32(offset, normal.x, true); offset += 4;
      view.setFloat32(offset, normal.y, true); offset += 4;
      view.setFloat32(offset, normal.z, true); offset += 4;
      
      // 写入三个顶点坐标（36字节，9个float32）
      view.setFloat32(offset, v1.x * scale, true); offset += 4;
      view.setFloat32(offset, v1.y * scale, true); offset += 4;
      view.setFloat32(offset, v1.z * scale, true); offset += 4;
      
      view.setFloat32(offset, v2.x * scale, true); offset += 4;
      view.setFloat32(offset, v2.y * scale, true); offset += 4;
      view.setFloat32(offset, v2.z * scale, true); offset += 4;
      
      view.setFloat32(offset, v3.x * scale, true); offset += 4;
      view.setFloat32(offset, v3.y * scale, true); offset += 4;
      view.setFloat32(offset, v3.z * scale, true); offset += 4;
      
      // 属性字节计数（2字节，通常为0）
      view.setUint16(offset, 0, true); offset += 2;
    }
    
    return buffer;
  };

  const generateOBJ = (geometry: LensGeometry, scale: number): string => {
    let obj = '# Caustic Lens\n';
    obj += `# Generated from ${currentImage?.name || 'image'}\n\n`;
    
    // 顶点 - 降低精度从6位到3位小数
    for (const vertex of geometry.vertices) {
      obj += `v ${(vertex.x * scale).toFixed(3)} ${(vertex.y * scale).toFixed(3)} ${(vertex.z * scale).toFixed(3)}\n`;
    }
    
    obj += '\n';
    
    // 简化面片格式，不包含UV和法向量索引以减少文件大小
    for (const face of geometry.faces) {
      const f1 = face[0] + 1; // OBJ索引从1开始
      const f2 = face[1] + 1;
      const f3 = face[2] + 1;
      obj += `f ${f1} ${f2} ${f3}\n`;
    }
    
    return obj;
  };

  const generateGCode = (geometry: LensGeometry, scale: number): string => {
    let gcode = '; Caustic Lens G-Code\n';
    gcode += '; Generated for 3D printing\n\n';
    gcode += 'G21 ; Set units to millimeters\n';
    gcode += 'G90 ; Use absolute positioning\n';
    gcode += 'M82 ; Use absolute distances for extrusion\n';
    gcode += 'G28 ; Home all axes\n\n';
    
    // 简化的G-Code生成（实际应用中需要更复杂的切片算法）
    gcode += '; Start printing\n';
    gcode += 'M104 S200 ; Set extruder temperature\n';
    gcode += 'M140 S60 ; Set bed temperature\n';
    gcode += 'M109 S200 ; Wait for extruder temperature\n';
    gcode += 'M190 S60 ; Wait for bed temperature\n\n';
    
    // 这里应该实现实际的切片算法
    gcode += '; Layer data would be generated here\n';
    gcode += '; This is a simplified example\n\n';
    
    gcode += 'M104 S0 ; Turn off extruder\n';
    gcode += 'M140 S0 ; Turn off bed\n';
    gcode += 'G28 X0 ; Home X axis\n';
    gcode += 'M84 ; Disable steppers\n';
    
    return gcode;
  };

  const generateJSON = (geometry: LensGeometry): string => {
    const data = {
      metadata: {
        type: 'CausticLens',
        version: '1.0',
        generator: 'Caustic Lens Generator',
        sourceImage: currentImage?.name || 'unknown',
        timestamp: new Date().toISOString(),
      },
      geometry,
      parameters: useProjectStore.getState().parameters,
    };
    
    return JSON.stringify(data, null, 2);
  };

  const handleExport = async () => {
    if (!geometry) {
      message.error('没有可导出的几何数据');
      return;
    }

    setExporting(true);
    setProgress(0);

    try {
      let content: string;
      let filename: string;
      let mimeType: string;

      const scaleFactors = {
        mm: 1,
        cm: 0.1,
        inch: 0.0393701,
      };
      
      const scale = exportOptions.scale * scaleFactors[exportOptions.units];
      setProgress(25);

      switch (exportOptions.format) {
        case 'stl':
          // 使用二进制STL格式，文件大小比ASCII格式小很多
          const binarySTL = generateBinarySTL(geometry, scale);
          const blob = new Blob([binarySTL], { type: 'application/octet-stream' });
          saveAs(blob, `lens.stl`);
          setProgress(100);
          message.success('二进制STL文件导出成功！文件大小已优化');
          setExporting(false);
          setTimeout(() => setProgress(0), 1000);
          return;
        case 'obj':
          content = generateOBJ(geometry, scale);
          filename = `lens.obj`;
          mimeType = 'text/plain';
          break;
        case 'gcode':
          content = generateGCode(geometry, scale);
          filename = `lens.gcode`;
          mimeType = 'text/plain';
          break;
        case 'ply':
          PLYExporter.export(geometry, 'lens.ply');
          setProgress(100);
          message.success('PLY文件导出成功！');
          setExporting(false);
          setTimeout(() => setProgress(0), 1000);
          return;
        case 'step':
          STEPExporter.export(geometry, 'lens.step');
          setProgress(100);
          message.success('STEP文件导出成功！');
          setExporting(false);
          setTimeout(() => setProgress(0), 1000);
          return;
        case 'json':
          content = generateJSON(geometry);
          filename = `lens.json`;
          mimeType = 'application/json';
          break;
        default:
          throw new Error('不支持的导出格式');
      }

      setProgress(75);

      const blob = new Blob([content], { type: mimeType });
      saveAs(blob, filename);
      
      setProgress(100);
      message.success(`${exportOptions.format.toUpperCase()} 文件导出成功！`);
    } catch (error) {
      console.error('Export failed:', error);
      message.error('导出失败，请重试');
    } finally {
      setExporting(false);
      setTimeout(() => setProgress(0), 1000);
    }
  };

  if (!geometry) {
    return (
      <Card 
        title={
          <Space>
            <FileOutlined />
            <span>文件导出</span>
          </Space>
        } 
        size="small"
      >
        <div className="text-center py-8">
          <FileOutlined className="text-4xl text-gray-300 mb-4" />
          <div className="text-gray-500 mb-2">暂无可导出的模型</div>
          <div className="text-sm text-gray-400">请先上传图片并生成3D透镜模型</div>
        </div>
      </Card>
    );
  }

  return (
    <Card 
      title={
        <Space>
          <FileOutlined />
          <span>文件导出</span>
        </Space>
      } 
      size="small"
      style={{ height: 'fit-content' }}
    >
      <div style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>
        <div>
          <Text className="text-sm font-medium" style={{ display: 'block', marginBottom: '8px' }}>导出格式</Text>
          <Select
            value={exportOptions.format}
            onChange={(format) => setExportOptions({ ...exportOptions, format })}
            style={{ width: '100%' }}
            size="middle"
          >
            <Option value="stl">STL (3D打印)</Option>
            <Option value="obj">OBJ (通用3D)</Option>
            <Option value="gcode">G-Code (打印机)</Option>
            <Option value="ply">PLY (Stanford格式)</Option>
            <Option value="step">STEP (CAD格式)</Option>
            <Option value="json">JSON (数据)</Option>
          </Select>
        </div>

        <div>
          <Text className="text-sm font-medium" style={{ display: 'block', marginBottom: '8px' }}>单位</Text>
          <Select
            value={exportOptions.units}
            onChange={(units) => setExportOptions({ ...exportOptions, units })}
            style={{ width: '100%' }}
            size="middle"
          >
            <Option value="mm">毫米 (mm)</Option>
            <Option value="cm">厘米 (cm)</Option>
            <Option value="inch">英寸 (inch)</Option>
          </Select>
        </div>

        <div>
          <Text className="text-sm font-medium" style={{ display: 'block', marginBottom: '8px' }}>缩放比例</Text>
          <Select
            value={exportOptions.scale}
            onChange={(scale) => setExportOptions({ ...exportOptions, scale })}
            style={{ width: '100%' }}
            size="middle"
          >
            <Option value={0.1}>0.1x</Option>
            <Option value={0.5}>0.5x</Option>
            <Option value={1}>1x</Option>
            <Option value={2}>2x</Option>
            <Option value={5}>5x</Option>
            <Option value={10}>10x</Option>
          </Select>
        </div>

        {(progress > 0 || exporting) && (
          <div style={{ marginTop: '8px' }}>
            <Progress 
              percent={progress} 
              size="small" 
              status={exporting ? 'active' : (progress === 100 ? 'success' : 'active')}
              showInfo={true}
              format={(percent) => exporting ? `导出中... ${percent}%` : `${percent}%`}
            />
          </div>
        )}

        <Button
          type="primary"
          block
          icon={<DownloadOutlined />}
          onClick={handleExport}
          loading={exporting}
          size="middle"
          style={{ marginTop: '8px', height: '40px' }}
          disabled={exporting}
        >
          {exporting ? '导出中...' : `导出 ${exportOptions.format.toUpperCase()} 文件`}
        </Button>

        <div style={{ 
          fontSize: '12px', 
          color: '#999', 
          padding: '12px 0 0 0',
          borderTop: '1px solid #f0f0f0',
          display: 'flex',
          justifyContent: 'space-between'
        }}>
          <span>顶点数: {geometry.vertices.length}</span>
          <span>面数: {geometry.faces.length}</span>
        </div>
      </div>
    </Card>
  );
};